<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Our Approach &mdash; TailoredShapes</title>
  <meta name="description" content="We built the same federated API in three languages. Under load, they converge. The right question isn't which language is fastest.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  <link href="../styles.css" rel="stylesheet">
</head>
<body class="font-sans text-warm-800 antialiased bg-warm-50">

  <!-- Header -->
  <div class="relative grain grain-heavy bg-warm-950">
    <div class="relative max-w-3xl mx-auto px-6 py-8">
      <a href="../" class="text-sm text-warm-500 hover:text-warm-200 transition-colors">&larr; TailoredShapes</a>
    </div>
  </div>

  <!-- Article -->
  <article class="relative grain">
    <div class="relative max-w-3xl mx-auto px-6 py-24 md:py-32">
      <p class="text-xs font-medium tracking-[0.2em] uppercase text-warm-400 mb-6">Perspective</p>
      <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">Speed is a distraction</h1>

      <div class="mt-8 space-y-6 text-warm-500 leading-relaxed max-w-xl">

        <p>
          The most common technology selection mistake is optimising for the wrong variable. Teams debate Rust vs Java vs TypeScript based on microbenchmarks that vanish behind a database query. They compare "hello world" throughput when what matters is whether their team can ship, operate, and maintain the system over its lifetime.
        </p>

        <h2 class="text-lg font-semibold text-warm-800 mt-12">The experiment</h2>

        <p>
          We built the same system three times. Same schema, same MongoDB, same queries. 13 entities, 19 resolvers, federated across multiple services. Java, Rust, TypeScript. Three complete implementations of the same architecture, tested under identical conditions.
        </p>

        <h2 class="text-lg font-semibold text-warm-800 mt-12">What we found</h2>

        <p>
          At baseline&mdash;a single user, no contention&mdash;Rust is 3&ndash;6x faster than Java. Sounds dramatic. But under realistic load with 10 concurrent users, the gap collapses to 1.3&ndash;2.6x. MongoDB becomes the bottleneck, not the application tier. The difference between "0.7ms" and "1.8ms" is undetectable to any human, any frontend, any SLA.
        </p>

      </div>

      <!-- Table 1 -->
      <div class="mt-10 max-w-lg">
        <p class="text-xs font-medium tracking-[0.2em] uppercase text-warm-400 mb-4">Under load, they converge</p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-warm-200 text-left text-warm-400">
              <th class="pb-3 font-medium">Test</th>
              <th class="pb-3 font-medium">Java</th>
              <th class="pb-3 font-medium">Rust</th>
              <th class="pb-3 font-medium">Difference</th>
            </tr>
          </thead>
          <tbody class="text-warm-600">
            <tr class="border-b border-warm-100">
              <td class="py-3">REST CRUD</td>
              <td class="py-3">1.84ms</td>
              <td class="py-3">1.38ms</td>
              <td class="py-3 text-warm-400">0.46ms</td>
            </tr>
            <tr class="border-b border-warm-100">
              <td class="py-3">GraphQL</td>
              <td class="py-3">1.76ms</td>
              <td class="py-3">0.69ms</td>
              <td class="py-3 text-warm-400">1.07ms</td>
            </tr>
            <tr>
              <td class="py-3">Federation</td>
              <td class="py-3">3.09ms</td>
              <td class="py-3">1.96ms</td>
              <td class="py-3 text-warm-400">1.13ms</td>
            </tr>
          </tbody>
        </table>
        <p class="mt-2 text-xs text-warm-400">10 concurrent users, same MongoDB instance, median latencies</p>
      </div>

      <div class="mt-12 space-y-6 text-warm-500 leading-relaxed max-w-xl">

        <h2 class="text-lg font-semibold text-warm-800">What actually matters</h2>

        <p>
          The numbers make it obvious: the real performance lever is infrastructure, not language. Switching from a single-node MongoDB to a replica set doubled latencies&mdash;in both languages equally. Adding proper indexes delivered a 100x improvement&mdash;again, regardless of language. The application tier is the last place to look for performance gains.
        </p>

      </div>

      <!-- Table 2 -->
      <div class="mt-10 max-w-lg">
        <p class="text-xs font-medium tracking-[0.2em] uppercase text-warm-400 mb-4">Infrastructure matters more</p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-warm-200 text-left text-warm-400">
              <th class="pb-3 font-medium">Change</th>
              <th class="pb-3 font-medium">Effect</th>
            </tr>
          </thead>
          <tbody class="text-warm-600">
            <tr class="border-b border-warm-100">
              <td class="py-3">Single-node &rarr; Replica set</td>
              <td class="py-3">2x latency increase (both languages)</td>
            </tr>
            <tr class="border-b border-warm-100">
              <td class="py-3">No indexes &rarr; Indexed</td>
              <td class="py-3">100x improvement (both languages)</td>
            </tr>
            <tr>
              <td class="py-3">Rust &rarr; Java</td>
              <td class="py-3">1.3&ndash;2.6x (under load)</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="mt-12 space-y-6 text-warm-500 leading-relaxed max-w-xl">

        <h2 class="text-lg font-semibold text-warm-800">The right question</h2>

        <p>
          Instead of "which language is fastest?", ask: "which language lets this team ship reliable software fastest?" That depends on the team's experience, the organisation's hiring pipeline, the ecosystem for the problem domain, and the operational model. A Rust service that nobody on the team can debug is slower than a Java service they understand.
        </p>

        <h2 class="text-lg font-semibold text-warm-800 mt-12">Our approach</h2>

        <p>
          We implement in the language that fits the team and the constraint. Same framework architecture, same patterns, proven in all three. Java when the team knows it, Rust when the constraints demand it, TypeScript when the ecosystem fits. The choice is about people and sustainability, not benchmarks.
        </p>

      </div>

      <div class="mt-16">
        <a href="../" class="text-sm text-warm-600 border-b border-warm-400 pb-px hover:text-warm-900 hover:border-warm-600 transition-colors">
          &larr; Back to TailoredShapes
        </a>
      </div>

    </div>
  </article>

  <!-- Footer -->
  <footer class="relative bg-warm-950 text-warm-500 grain grain-heavy">
    <div class="relative max-w-3xl mx-auto px-6 py-16">
      <div class="flex flex-col md:flex-row md:items-baseline md:justify-between gap-6">
        <div>
          <p class="text-warm-100 font-medium tracking-tight">TailoredShapes</p>
        </div>
        <div class="flex gap-6 text-sm">
          <a href="mailto:tom@tailoredshapes.com" class="text-warm-500 hover:text-warm-200 transition-colors">tom@tailoredshapes.com</a>
          <a href="https://github.com/tailoredshapes" class="text-warm-500 hover:text-warm-200 transition-colors">GitHub</a>
        </div>
      </div>
      <div class="mt-12 pt-8 border-t border-warm-800 text-xs text-warm-700">
        <p>&copy; 2025 TailoredShapes</p>
      </div>
    </div>
  </footer>

</body>
</html>
